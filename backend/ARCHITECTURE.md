# Backend Architecture

## Stack

Go, chi router, PostgreSQL 16 via pgx, sqlc for query codegen, golang-migrate for migrations, JWT (HS256) auth.

## Structure

```
cmd/api/main.go          -- entry point, wiring
internal/
  config/config.go       -- env vars via envconfig
  server/
    server.go            -- HTTP server, graceful shutdown
    routes.go            -- chi route registration
  handler/               -- HTTP layer: parse request, validate, call service, respond
    respond/respond.go   -- JSON/error response helpers
  service/               -- business logic, pgtype conversions
    convert.go           -- pgtype.Numeric/Date/UUID <-> Go type helpers
  store/                 -- sqlc-generated DB access (DO NOT EDIT)
  middleware/auth.go     -- JWT auth middleware
  dto/dto.go             -- all request/response types
migrations/              -- SQL up/down files + embed.go
queries/                 -- sqlc SQL definitions
```

## Layering

```
handler -> service -> store (sqlc Queries)
```

- **handler**: Extracts user ID from context, decodes JSON body, validates with `go-playground/validator`, calls service, writes response via `respond.JSON/Error/NoContent`.
- **service**: Business logic. Receives Go types (uuid.UUID, dto structs). Converts to pgtype for store calls. Converts store models back to dto responses. Each service holds a `*store.Queries`.
- **store**: Auto-generated by sqlc from `queries/*.sql`. Uses `pgxpool` connection. Never edit directly — edit SQL in `queries/` then run `sqlc generate`.

## Dependency Wiring (main.go)

Manual constructor injection, no DI framework:

```
config.Load() -> pgxpool.New() -> store.New(pool) ->
  service.NewAuth(queries, jwtSecret)
  service.NewAccount(queries)
  ... (one service per domain) ->
    handler.NewAuth(authSvc)
    handler.NewAccount(accountSvc)
    ... ->
      server.NewRouter(authMw, authH, accountH, ...)
```

Migrations run at startup via embedded SQL files (`migrations/embed.go`).

## Auth

- Register/Login return `{ access_token, refresh_token, user }`.
- Access token: 15min, type="access". Refresh token: 7 days, type="refresh".
- JWT claims: `{ sub: userID, type: "access"|"refresh", iat, exp }`.
- Middleware extracts `sub` from Bearer token, stores `uuid.UUID` in context.
- All service methods receive `userID` — every DB query filters by `user_id`.

```go
userID := middleware.UserID(r.Context())  // in any handler
```

## pgtype Conversions (service/convert.go)

PostgreSQL decimals map to `pgtype.Numeric` (not float64). Key helpers:

| Function | Direction | Notes |
|---|---|---|
| `numericFromString(s)` | string -> Numeric | Uses `n.Scan(s)`, empty = invalid |
| `numericToString(n)` | Numeric -> string | Via big.Float, 2 decimal places |
| `numericAdd(a, b)` | arithmetic | big.Float intermediary |
| `numericSub(a, b)` | arithmetic | big.Float intermediary |
| `dateFromString(s)` | "YYYY-MM-DD" -> pgtype.Date | |
| `dateToString(d)` | pgtype.Date -> "YYYY-MM-DD" | |
| `uuidToNullable(id)` | *uuid.UUID -> pgtype.UUID | nil = {Valid:false} |
| `nullableToUUID(id)` | pgtype.UUID -> *uuid.UUID | invalid = nil |

## SQL Patterns (queries/)

sqlc annotations: `-- name: FuncName :one/:many/:exec/:copyfrom`

- **Nullable filters**: Use `sqlc.narg('param')` for optional WHERE clauses:
  ```sql
  AND (sqlc.narg('account_id')::UUID IS NULL OR account_id = sqlc.narg('account_id'))
  ```
- **Pagination**: `LIMIT @lim OFFSET @off` with separate `Count*` query for total.
- **Upsert**: `ON CONFLICT ... DO UPDATE` for exchange rates.
- **Bulk insert**: `:copyfrom` for CSV import (uses pgx CopyFrom).
- **Auth check**: Every query includes `WHERE user_id = $N` or `AND user_id = $N`.

## API Conventions

- Prefix: `/api/v1/`
- Public: `/auth/register`, `/auth/login`, `/auth/refresh`
- Protected: everything else (requires Bearer token)
- List responses: `{ "data": [...] }` or `{ "data": [...], "pagination": { page, per_page, total } }`
- Errors: `{ "error": { "code": "SNAKE_CASE", "message": "human text" } }`
- Monetary amounts: string (decimal), never float. Always paired with currency code.

## Domain Rules

- **Account balance** = `initial_balance + SUM(income) - SUM(expense)`. Computed on read, not stored.
- **Transfers** create two linked transactions sharing a `transfer_id` UUID: expense on source account, income on destination. Cross-currency transfers store `exchange_rate` and may have different amounts.
- **Categories** are hierarchical (one level: parent + children). Type is `income` or `expense`. Default categories seeded on user registration. Delete blocked if category has children or transactions.
- **Transaction types**: `income` and `expense` only (transfers use these types internally).
- **Reports** exclude transfer transactions (`WHERE transfer_id IS NULL`) to avoid double-counting.

## Validation

Uses `go-playground/validator` struct tags on DTOs:

```go
Username string `validate:"required,min=3,max=50"`
Type     string `validate:"required,oneof=bank cash credit_card savings"`
Currency string `validate:"required,len=3"`
```

Validated in handlers before service calls.

## Error Handling

Sentinel errors in service layer, matched in handlers:

| Error | HTTP Status | Code |
|---|---|---|
| `ErrNotFound` | 404 | NOT_FOUND |
| `ErrUserExists` | 409 | USER_EXISTS |
| `ErrInvalidCredentials` | 401 | INVALID_CREDENTIALS |
| `ErrInvalidToken` | 401 | INVALID_TOKEN |
| `ErrCategoryHasChildren` | 409 | HAS_CHILDREN |
| `ErrCategoryHasTransactions` | 409 | HAS_TRANSACTIONS |

## Adding a New Endpoint

1. Add SQL query in `queries/` -> run `sqlc generate`
2. Add request/response types in `dto/dto.go`
3. Add service method (convert dto -> pgtype, call store, convert back)
4. Add handler method (parse request, validate, call service, respond)
5. Register route in `server/routes.go`
6. Wire service+handler in `cmd/api/main.go`
