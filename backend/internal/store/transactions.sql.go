// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transactions.sql

package store

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const balanceHistory = `-- name: BalanceHistory :many
WITH daily AS (
    SELECT
        t.date,
        SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE -t.amount END)::DECIMAL(15,2) AS daily_change
    FROM transactions t
    WHERE t.account_id = $1
        AND t.user_id = $2
        AND t.date >= $3
        AND t.date <= $4
    GROUP BY t.date
),
start_balance AS (
    SELECT
        a.initial_balance
        + COALESCE(SUM(CASE WHEN t.type = 'income' THEN t.amount ELSE -t.amount END), 0)::DECIMAL(15,2) AS balance
    FROM accounts a
    LEFT JOIN transactions t
        ON t.account_id = a.id
        AND t.user_id = a.user_id
        AND t.date < $3
    WHERE a.id = $1
        AND a.user_id = $2
    GROUP BY a.initial_balance
)
SELECT
    d.date,
    (sb.balance + SUM(d.daily_change) OVER (ORDER BY d.date))::DECIMAL(15,2) AS balance
FROM daily d
CROSS JOIN start_balance sb
ORDER BY d.date
`

type BalanceHistoryParams struct {
	AccountID uuid.UUID   `json:"account_id"`
	UserID    uuid.UUID   `json:"user_id"`
	DateFrom  pgtype.Date `json:"date_from"`
	DateTo    pgtype.Date `json:"date_to"`
}

type BalanceHistoryRow struct {
	Date    pgtype.Date    `json:"date"`
	Balance pgtype.Numeric `json:"balance"`
}

func (q *Queries) BalanceHistory(ctx context.Context, arg BalanceHistoryParams) ([]BalanceHistoryRow, error) {
	rows, err := q.db.Query(ctx, balanceHistory,
		arg.AccountID,
		arg.UserID,
		arg.DateFrom,
		arg.DateTo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BalanceHistoryRow{}
	for rows.Next() {
		var i BalanceHistoryRow
		if err := rows.Scan(&i.Date, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type BulkCreateTransactionsParams struct {
	UserID      uuid.UUID      `json:"user_id"`
	AccountID   uuid.UUID      `json:"account_id"`
	CategoryID  pgtype.UUID    `json:"category_id"`
	Type        string         `json:"type"`
	Amount      pgtype.Numeric `json:"amount"`
	Description string         `json:"description"`
	Date        pgtype.Date    `json:"date"`
}

type BulkCreateTransactionsFullParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	AccountID    uuid.UUID      `json:"account_id"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	Type         string         `json:"type"`
	Amount       pgtype.Numeric `json:"amount"`
	Description  string         `json:"description"`
	Date         pgtype.Date    `json:"date"`
	TransferID   pgtype.UUID    `json:"transfer_id"`
	ExchangeRate pgtype.Numeric `json:"exchange_rate"`
}

const countTransactions = `-- name: CountTransactions :one
WITH RECURSIVE expanded_categories AS (
    SELECT id FROM categories
    WHERE id = ANY($3::UUID[])
    UNION
    SELECT c.id FROM categories c
    INNER JOIN expanded_categories ec ON c.parent_id = ec.id
)
SELECT COUNT(*) FROM transactions t
WHERE t.user_id = $1
    AND (cardinality($2::UUID[]) = 0 OR t.account_id = ANY($2))
    AND (cardinality($3::UUID[]) = 0 OR t.category_id IN (SELECT id FROM expanded_categories))
    AND ($4::VARCHAR IS NULL OR t.type = $4)
    AND ($5::DATE IS NULL OR t.date >= $5)
    AND ($6::DATE IS NULL OR t.date <= $6)
`

type CountTransactionsParams struct {
	UserID      uuid.UUID   `json:"user_id"`
	AccountIds  []uuid.UUID `json:"account_ids"`
	CategoryIds []uuid.UUID `json:"category_ids"`
	Type        pgtype.Text `json:"type"`
	DateFrom    pgtype.Date `json:"date_from"`
	DateTo      pgtype.Date `json:"date_to"`
}

func (q *Queries) CountTransactions(ctx context.Context, arg CountTransactionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactions,
		arg.UserID,
		arg.AccountIds,
		arg.CategoryIds,
		arg.Type,
		arg.DateFrom,
		arg.DateTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (user_id, account_id, category_id, type, amount, description, date, transfer_id, exchange_rate)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, account_id, category_id, type, amount, description, date, transfer_id, exchange_rate, created_at, updated_at
`

type CreateTransactionParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	AccountID    uuid.UUID      `json:"account_id"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	Type         string         `json:"type"`
	Amount       pgtype.Numeric `json:"amount"`
	Description  string         `json:"description"`
	Date         pgtype.Date    `json:"date"`
	TransferID   pgtype.UUID    `json:"transfer_id"`
	ExchangeRate pgtype.Numeric `json:"exchange_rate"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.UserID,
		arg.AccountID,
		arg.CategoryID,
		arg.Type,
		arg.Amount,
		arg.Description,
		arg.Date,
		arg.TransferID,
		arg.ExchangeRate,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.Type,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.TransferID,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const dashboardSummary = `-- name: DashboardSummary :one
SELECT
    COALESCE(SUM(CASE WHEN type = 'income' AND transfer_id IS NULL THEN amount ELSE 0 END), 0)::DECIMAL(15,2) AS total_income,
    COALESCE(SUM(CASE WHEN type = 'expense' AND transfer_id IS NULL THEN amount ELSE 0 END), 0)::DECIMAL(15,2) AS total_expense
FROM transactions
WHERE user_id = $1
    AND date >= $2
    AND date <= $3
`

type DashboardSummaryParams struct {
	UserID   uuid.UUID   `json:"user_id"`
	DateFrom pgtype.Date `json:"date_from"`
	DateTo   pgtype.Date `json:"date_to"`
}

type DashboardSummaryRow struct {
	TotalIncome  pgtype.Numeric `json:"total_income"`
	TotalExpense pgtype.Numeric `json:"total_expense"`
}

func (q *Queries) DashboardSummary(ctx context.Context, arg DashboardSummaryParams) (DashboardSummaryRow, error) {
	row := q.db.QueryRow(ctx, dashboardSummary, arg.UserID, arg.DateFrom, arg.DateTo)
	var i DashboardSummaryRow
	err := row.Scan(&i.TotalIncome, &i.TotalExpense)
	return i, err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = $1 AND user_id = $2
`

type DeleteTransactionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteTransaction(ctx context.Context, arg DeleteTransactionParams) error {
	_, err := q.db.Exec(ctx, deleteTransaction, arg.ID, arg.UserID)
	return err
}

const deleteTransactionByTransferID = `-- name: DeleteTransactionByTransferID :exec
DELETE FROM transactions WHERE transfer_id = $1 AND user_id = $2
`

type DeleteTransactionByTransferIDParams struct {
	TransferID pgtype.UUID `json:"transfer_id"`
	UserID     uuid.UUID   `json:"user_id"`
}

func (q *Queries) DeleteTransactionByTransferID(ctx context.Context, arg DeleteTransactionByTransferIDParams) error {
	_, err := q.db.Exec(ctx, deleteTransactionByTransferID, arg.TransferID, arg.UserID)
	return err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, user_id, account_id, category_id, type, amount, description, date, transfer_id, exchange_rate, created_at, updated_at FROM transactions WHERE id = $1 AND user_id = $2
`

type GetTransactionParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetTransaction(ctx context.Context, arg GetTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, arg.ID, arg.UserID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.Type,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.TransferID,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsByTransferID = `-- name: GetTransactionsByTransferID :many
SELECT id, user_id, account_id, category_id, type, amount, description, date, transfer_id, exchange_rate, created_at, updated_at FROM transactions WHERE transfer_id = $1 AND user_id = $2
`

type GetTransactionsByTransferIDParams struct {
	TransferID pgtype.UUID `json:"transfer_id"`
	UserID     uuid.UUID   `json:"user_id"`
}

func (q *Queries) GetTransactionsByTransferID(ctx context.Context, arg GetTransactionsByTransferIDParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByTransferID, arg.TransferID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.TransferID,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
WITH RECURSIVE expanded_categories AS (
    SELECT id FROM categories
    WHERE id = ANY($3::UUID[])
    UNION
    SELECT c.id FROM categories c
    INNER JOIN expanded_categories ec ON c.parent_id = ec.id
)
SELECT t.id, t.user_id, t.account_id, t.category_id, t.type, t.amount, t.description, t.date, t.transfer_id, t.exchange_rate, t.created_at, t.updated_at FROM transactions t
WHERE t.user_id = $1
    AND (cardinality($2::UUID[]) = 0 OR t.account_id = ANY($2))
    AND (cardinality($3::UUID[]) = 0 OR t.category_id IN (SELECT id FROM expanded_categories))
    AND ($4::VARCHAR IS NULL OR t.type = $4)
    AND ($5::DATE IS NULL OR t.date >= $5)
    AND ($6::DATE IS NULL OR t.date <= $6)
ORDER BY t.date DESC, t.created_at DESC
LIMIT $8 OFFSET $7
`

type ListTransactionsParams struct {
	UserID      uuid.UUID   `json:"user_id"`
	AccountIds  []uuid.UUID `json:"account_ids"`
	CategoryIds []uuid.UUID `json:"category_ids"`
	Type        pgtype.Text `json:"type"`
	DateFrom    pgtype.Date `json:"date_from"`
	DateTo      pgtype.Date `json:"date_to"`
	Off         int32       `json:"off"`
	Lim         int32       `json:"lim"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.UserID,
		arg.AccountIds,
		arg.CategoryIds,
		arg.Type,
		arg.DateFrom,
		arg.DateTo,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.CategoryID,
			&i.Type,
			&i.Amount,
			&i.Description,
			&i.Date,
			&i.TransferID,
			&i.ExchangeRate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlyIncomeExpense = `-- name: MonthlyIncomeExpense :many
SELECT
    date_trunc('month', date)::DATE AS month,
    COALESCE(SUM(CASE WHEN type = 'income' AND transfer_id IS NULL THEN amount ELSE 0 END), 0)::DECIMAL(15,2) AS income,
    COALESCE(SUM(CASE WHEN type = 'expense' AND transfer_id IS NULL THEN amount ELSE 0 END), 0)::DECIMAL(15,2) AS expense
FROM transactions
WHERE user_id = $1
    AND date >= $2
    AND date <= $3
GROUP BY date_trunc('month', date)
ORDER BY month
`

type MonthlyIncomeExpenseParams struct {
	UserID   uuid.UUID   `json:"user_id"`
	DateFrom pgtype.Date `json:"date_from"`
	DateTo   pgtype.Date `json:"date_to"`
}

type MonthlyIncomeExpenseRow struct {
	Month   pgtype.Date    `json:"month"`
	Income  pgtype.Numeric `json:"income"`
	Expense pgtype.Numeric `json:"expense"`
}

func (q *Queries) MonthlyIncomeExpense(ctx context.Context, arg MonthlyIncomeExpenseParams) ([]MonthlyIncomeExpenseRow, error) {
	rows, err := q.db.Query(ctx, monthlyIncomeExpense, arg.UserID, arg.DateFrom, arg.DateTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonthlyIncomeExpenseRow{}
	for rows.Next() {
		var i MonthlyIncomeExpenseRow
		if err := rows.Scan(&i.Month, &i.Income, &i.Expense); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const spendingByCategory = `-- name: SpendingByCategory :many
SELECT
    c.id AS category_id,
    c.name AS category_name,
    c.parent_id,
    COALESCE(SUM(t.amount), 0)::DECIMAL(15,2) AS total
FROM transactions t
JOIN categories c ON t.category_id = c.id
WHERE t.user_id = $1
    AND t.type = 'expense'
    AND t.date >= $2
    AND t.date <= $3
    AND t.transfer_id IS NULL
GROUP BY c.id, c.name, c.parent_id
ORDER BY total DESC
`

type SpendingByCategoryParams struct {
	UserID   uuid.UUID   `json:"user_id"`
	DateFrom pgtype.Date `json:"date_from"`
	DateTo   pgtype.Date `json:"date_to"`
}

type SpendingByCategoryRow struct {
	CategoryID   uuid.UUID      `json:"category_id"`
	CategoryName string         `json:"category_name"`
	ParentID     pgtype.UUID    `json:"parent_id"`
	Total        pgtype.Numeric `json:"total"`
}

func (q *Queries) SpendingByCategory(ctx context.Context, arg SpendingByCategoryParams) ([]SpendingByCategoryRow, error) {
	rows, err := q.db.Query(ctx, spendingByCategory, arg.UserID, arg.DateFrom, arg.DateTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SpendingByCategoryRow{}
	for rows.Next() {
		var i SpendingByCategoryRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.ParentID,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET account_id = $2, category_id = $3, type = $4, amount = $5, description = $6, date = $7, updated_at = now()
WHERE id = $1 AND user_id = $8
RETURNING id, user_id, account_id, category_id, type, amount, description, date, transfer_id, exchange_rate, created_at, updated_at
`

type UpdateTransactionParams struct {
	ID          uuid.UUID      `json:"id"`
	AccountID   uuid.UUID      `json:"account_id"`
	CategoryID  pgtype.UUID    `json:"category_id"`
	Type        string         `json:"type"`
	Amount      pgtype.Numeric `json:"amount"`
	Description string         `json:"description"`
	Date        pgtype.Date    `json:"date"`
	UserID      uuid.UUID      `json:"user_id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransaction,
		arg.ID,
		arg.AccountID,
		arg.CategoryID,
		arg.Type,
		arg.Amount,
		arg.Description,
		arg.Date,
		arg.UserID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.Type,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.TransferID,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTransferTransaction = `-- name: UpdateTransferTransaction :one
UPDATE transactions
SET account_id = $2, amount = $3, description = $4, date = $5, exchange_rate = $6, updated_at = now()
WHERE id = $1 AND user_id = $7
RETURNING id, user_id, account_id, category_id, type, amount, description, date, transfer_id, exchange_rate, created_at, updated_at
`

type UpdateTransferTransactionParams struct {
	ID           uuid.UUID      `json:"id"`
	AccountID    uuid.UUID      `json:"account_id"`
	Amount       pgtype.Numeric `json:"amount"`
	Description  string         `json:"description"`
	Date         pgtype.Date    `json:"date"`
	ExchangeRate pgtype.Numeric `json:"exchange_rate"`
	UserID       uuid.UUID      `json:"user_id"`
}

func (q *Queries) UpdateTransferTransaction(ctx context.Context, arg UpdateTransferTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransferTransaction,
		arg.ID,
		arg.AccountID,
		arg.Amount,
		arg.Description,
		arg.Date,
		arg.ExchangeRate,
		arg.UserID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.CategoryID,
		&i.Type,
		&i.Amount,
		&i.Description,
		&i.Date,
		&i.TransferID,
		&i.ExchangeRate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
