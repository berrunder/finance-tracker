# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build & Run Commands

```sh
# Start PostgreSQL (required for local development)
docker compose up -d db

# Run backend (from repo root)
make dev-backend

# Regenerate sqlc code after editing queries/*.sql
make sqlc                    # or: cd backend && sqlc generate

# Run all tests
cd backend && go test ./...

# Run a single test
cd backend && go test ./internal/service/ -run TestFunctionName

# Docker (full stack)
make up       # docker compose up -d --build
make down     # docker compose down
```

Required env vars: `DATABASE_URL` (postgres connection string), `JWT_SECRET` (HMAC key, 32+ chars). Optional: `PORT` (default 8080).

## Architecture

Go 1.24 backend — chi router, PostgreSQL 16 (pgx + sqlc), JWT auth (HS256), golang-migrate.

### Layer Flow

```
handler -> service -> store (sqlc-generated)
```

- **handler/**: HTTP layer. Parses requests, validates with `go-playground/validator` struct tags, calls service, responds via `respond.JSON/Error/NoContent`. Extracts user ID with `middleware.UserID(r.Context())`.
- **service/**: Business logic. Receives Go types, converts to pgtype for store calls using helpers in `service/convert.go`, converts store models back to DTOs.
- **store/**: **Auto-generated by sqlc — do not edit.** Edit SQL in `backend/queries/*.sql` then run `make sqlc`.
- **dto/dto.go**: All request/response types in one file.
- **cmd/api/main.go**: Entry point. Manual constructor injection (config -> pool -> queries -> services -> handlers -> router). Migrations run automatically at startup.

### Key Patterns

- **pgtype conversions**: PostgreSQL decimals use `pgtype.Numeric`, not float64. Use helpers in `service/convert.go` (`numericFromString`, `numericToString`, `numericAdd`, `numericSub`, `dateFromString`, `dateToString`, `uuidToNullable`, `nullableToUUID`).
- **Nullable SQL filters**: `sqlc.narg('param')::TYPE IS NULL OR column = sqlc.narg('param')` pattern for optional WHERE clauses.
- **Monetary amounts**: Always strings (decimal), never float. Paired with currency code.
- **Auth scoping**: Every DB query filters by `user_id`. Services receive userID as parameter.
- **Transfers**: Two linked transactions sharing a `transfer_id` UUID (expense on source, income on destination).
- **Reports**: Exclude transfer transactions (`WHERE transfer_id IS NULL`) to avoid double-counting.
- **Sentinel errors**: Service layer defines `ErrNotFound`, `ErrUserExists`, `ErrInvalidCredentials`, etc. Handlers match these to HTTP status codes.

### Adding a New Endpoint

1. Add SQL in `backend/queries/` -> `make sqlc`
2. Add request/response types in `dto/dto.go`
3. Add service method (dto <-> pgtype conversions)
4. Add handler method (parse, validate, call service, respond)
5. Register route in `server/routes.go`
6. Wire service + handler in `cmd/api/main.go`

### sqlc Configuration

`backend/sqlc.yaml` — generates to `internal/store/` package, uses `pgx/v5`, maps `uuid` DB type to `google/uuid.UUID`. Annotations: `-- name: FuncName :one/:many/:exec/:copyfrom`.
